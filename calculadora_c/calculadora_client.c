/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"
#include <math.h>

void
calculadora_1(char *host, int tipo_operacion, float num1, char *operador, float num2)
{
	CLIENT *clnt;
	float *result;

#ifndef	DEBUG
	clnt = clnt_create (host, CALCULADORA, CALC, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	switch(tipo_operacion){
		// Operaciones básicas:
		case 0:
			switch(operador[0]){
				case '+':
					result = suma_1(num1, num2, clnt);
					break;
				case 'x':
					result = multiplicacion_1(num1, num2, clnt);
					break;
				case '-':
					result = resta_1(num1, num2, clnt);
					break;
				case '/':
					result = division_1(num1, num2, clnt);
					if(result[0] == -1.0){
						printf("Error, no se puede dividir entre 0.\n");
						exit(-1);
					}
					break;
				default:
					printf("Operador no valido.\n");
					exit(-1);
					break;
			}
			break;
		// Operaciones trigonométricas:
		case 1:
			if(strcmp(operador, "sin") == 0) result = seno_1(num1, clnt);
			else if(strcmp(operador, "cos") == 0) result = coseno_1(num1, clnt);
			else if(strcmp(operador, "tan") == 0) result = tangente_1(num1, clnt);
			else if(strcmp(operador, "asin") == 0) result = arcoseno_1(num1, clnt);
			else if(strcmp(operador, "acos") == 0) result = arcocoseno_1(num1, clnt);
			else if(strcmp(operador, "atan") == 0) result = arcotangente_1(num1, clnt);
			else{
				printf("Operador no valido.\n");
				exit(-1);
			}
			break;
		// Raíces y potencias:
		case 2:
			if(strcmp(operador, "sqrt") == 0) result = raiz_cuadrada_1(num1, clnt);
			else if(strcmp(operador, "pow") == 0) result = potencia_1(num1, num2, clnt);
			else{
				printf("Operador no valido.\n");
				exit(-1);
			}
			break;
	}
	
	if(result == (float*) NULL){
		clnt_perror(clnt, "call failed");
	}else if(tipo_operacion == 0){
		printf("Operacion: %f %s %f = %f\n", num1, operador, num2, *result);
	}else if(tipo_operacion == 1){
		printf("Operacion: %s(%f) = %f\n", operador, num1, *result);
	}else if(tipo_operacion == 2){
		if(strcmp(operador, "sqrt") == 0) printf("Operacion: %s(%f) = %f\n", operador, num1, *result);
		else printf("Operacion: %s(%f,%f) = %f\n", operador, num1, num2, *result);
	}
	
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}

void imprimir_vector(float_array v){
	printf("{ ");
	for(int i = 0; i < v.tam; i++){
		printf("%f ", v.vector[i]);
	}
	printf("} ");
}

void
calculadora_2(char *host, float_array v1, char *operador, float_array v2)
{
	CLIENT *clnt;
	float_array *result;
	float *result_escalar;

#ifndef	DEBUG
	clnt = clnt_create (host, CALCULADORA, CALC, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	switch(operador[0]){
		case '+':
			result = suma_vectores_1(v1, v2, clnt);
			break;
		case 'x':
			if(v1.tam == 3 && v2.tam == 3)
				result = producto_vectorial_1(v1, v2, clnt);
			else{
				printf("Para hacer productos vectoriales, los vectores deben ser de 3 elementos.\n");
				exit(-1);
			}
			break;
		case '-':
			result = resta_vectores_1(v1, v2, clnt);
			break;
		case 'o':
			result_escalar = producto_escalar_1(v1, v2, clnt);
			break;
		default:
			printf("Operador no valido.\n");
			exit(-1);
			break;
	}
	
	if(strcmp(operador, "o") == 0){
		if(result_escalar == (float*) NULL){
			clnt_perror(clnt, "call failed.vector");
		}else{
			printf("Operacion: ");
			imprimir_vector(v1);
			printf("%s ", operador);
			imprimir_vector(v2);
			printf("= %f\n", *result_escalar);
		}
	}else{
		if(result->vector == (float*) NULL){
			clnt_perror(clnt, "call failed.vector");
		}else{
			printf("Operacion: ");
			imprimir_vector(v1);
			printf("%s ", operador);
			imprimir_vector(v2);
			printf("= ");
			imprimir_vector(*result);
			printf("\n");
		}
	}
	 
	
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}

void imprimir_matriz(float_matrix m){
	for(int i = 0; i < m.tam1; i++){
		printf("| ");
		for(int j = 0; j < m.tam2; j++){
			printf("%f   ", m.m[j+m.tam1*i]);
		}
		printf("|\n");
	}
}

void
calculadora_3(char *host, float_matrix v1, char *operador, float_matrix v2)
{
	CLIENT *clnt;
	float_matrix *result;

#ifndef	DEBUG
	clnt = clnt_create (host, CALCULADORA, CALC, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	switch(operador[0]){
		case '+':
			if(v1.tam1 == v2.tam1 && v1.tam2 == v2.tam2)
				result = suma_matrices_1(v1, v2, clnt);
			else{
				printf("Para realizar suma de matrices, deben tener el mismo tamaño.\n");
				exit(-1);
			}
			break;
		case 'x':
			if(v1.tam2 == v2.tam1)
				result = multiplicacion_matrices_1(v1, v2, clnt);
			else{
				printf("Para realizar producto de matrices, el numero de columnas de la primera matriz debe ser igual al numero de filas de la segunda.\n");
				exit(-1);
			}
			break;
		case '-':
			if(v1.tam1 == v2.tam1 && v1.tam2 == v2.tam2)
				result = resta_matrices_1(v1, v2, clnt);
			else{
				printf("Para realizar resta de matrices, deben tener el mismo tamaño.\n");
				exit(-1);
			}
			break;
		case '/':
			result = division_matriz_real_1(v1, v2.m[0], clnt);
			break;
		default:
			printf("Operador no valido.\n");
			exit(-1);
			break;
	}
	
	if(result->m == (float*) NULL){
		clnt_perror(clnt, "call failed.vector");
	}else if(strcmp(operador, "/") != 0){
		printf("Operacion:\n");
		printf("Primera matriz:\n");
		imprimir_matriz(v1);
		printf("\nOperador: %s\n", operador);
		printf("\nSegunda matriz:\n");
		imprimir_matriz(v2);
		printf("\nResultado:\n");
		imprimir_matriz(*result);
		printf("\n");
	}else{
		printf("Operacion:\n");
		printf("Matriz:\n");
		imprimir_matriz(v1);
		printf("\nOperador: %s\n", operador);
		printf("\nValor: %f\n", v2.m[0]);
		printf("\nResultado:\n");
		imprimir_matriz(*result);
		printf("\n");
	}
	 
	
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}

int noDigito(char *cadena){
	int no_digito = 0;
	if(strcmp(cadena, "+") == 0) no_digito = 1;
	else if(strcmp(cadena, "-") == 0) no_digito = 1;
	else if(strcmp(cadena, "x") == 0) no_digito = 1;
	else if(strcmp(cadena, "/") == 0) no_digito = 1;
	else if(strcmp(cadena, "o") == 0) no_digito = 1;

	return no_digito;
}

int
main (int argc, char *argv[])
{
	char *host, *operador;
	float num1, num2;
	int tipo_operacion;
	float_array v1, v2;
	float_matrix m, m2;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	tipo_operacion = atoi(argv[2]);

	// Operaciones básicas:
	if(tipo_operacion == 0){
		num1 = atof(argv[3]);
		operador = argv[4];
		num2 = atof(argv[5]);
		calculadora_1 (host, tipo_operacion, num1, operador, num2);
	}
	// Operaciones trigonométricas:
	else if(tipo_operacion == 1){
		operador = argv[3];
		num1 = atof(argv[4]);
		calculadora_1 (host, tipo_operacion, num1, operador, 0.0);
	}
	// Raíces y potencias: 
	else if(tipo_operacion == 2){
		operador = argv[3];
		num1 = atof(argv[4]);
		if(strcmp(operador, "sqrt") == 0){
			if(argc == 5) calculadora_1 (host, tipo_operacion, num1, operador, 0.0);
			else{
				printf("Error en el paso de parametros: las raices solo necesitan un valor.\n");
				exit(-1);
			}
		}else{
			num2 = atof(argv[5]);
			calculadora_1 (host, tipo_operacion, num1, operador, num2);
		} 
	}
	// Operaciones con vectores:
	else if(tipo_operacion == 3){
		int contador = 3;
		int derecha = 0;
		int inicio = 0;

		while (contador < argc){
			if(noDigito(argv[contador]) == 1){
				derecha = 1;
				v1.tam = contador-3;
				v2.tam = contador-3;
				operador = argv[contador];
			}else if(derecha == 0){
				v1.vector[contador-3] = atof(argv[contador]);
			}else{
				v2.vector[inicio] = atof(argv[contador]);
				inicio++;
			}
			contador++;
		}

		calculadora_2(host, v1, operador, v2);
	}
	// Operaciones con matrices:
	else if(tipo_operacion == 4){
		m.tam1 = atoi(argv[3]);
		m.tam2 = atoi(argv[4]);
		for(int i = 0; i < m.tam1 * m.tam2; i++) m.m[i] = atof(argv[i+5]);

		operador = argv[5 + m.tam1 * m.tam2];

		if(strcmp(operador, "/") != 0){
			m2.tam1 = atoi(argv[6 + m.tam1 * m.tam2]);
			m2.tam2 = atoi(argv[7 + m.tam1 * m.tam2]);
			for(int i = 0; i < m2.tam1 * m2.tam2; i++) m2.m[i] = atof(argv[i + m.tam1*m.tam2 + 8]);
			calculadora_3(host, m, operador, m2);
		}else{
			m2.m[0] = atof(argv[m.tam1*m.tam2 + 6]);
			calculadora_3(host, m, operador, m2);
		}
		
	}
	
	exit (0);
}
