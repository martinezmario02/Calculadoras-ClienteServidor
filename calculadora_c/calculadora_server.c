/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"
#include <math.h>

float *
suma_1_svc(float a, float b,  struct svc_req *rqstp)
{
	static float  result;

	result = a + b;

	return &result;
}

float *
multiplicacion_1_svc(float a, float b,  struct svc_req *rqstp)
{
	static float  result;

	result = a * b;

	return &result;
}

float *
resta_1_svc(float a, float b,  struct svc_req *rqstp)
{
	static float  result;

	result = a - b;

	return &result;
}

float *
division_1_svc(float a, float b,  struct svc_req *rqstp)
{
	static float  result;

	if(b != 0.0) result = a / b;
	else result = -1.0;

	return &result;
}

float *
seno_1_svc(float a,  struct svc_req *rqstp)
{
	static float  result;

	result = sin(a*M_PI/180.0);

	return &result;
}

float *
coseno_1_svc(float a,  struct svc_req *rqstp)
{
	static float  result;

	result = cos(a*M_PI/180.0);

	return &result;
}

float *
tangente_1_svc(float a,  struct svc_req *rqstp)
{
	static float  result;

	result = tan(a*M_PI/180.0);

	return &result;
}

float *
arcoseno_1_svc(float a,  struct svc_req *rqstp)
{
	static float  result;

	result = asin(a)*180.0/M_PI;

	return &result;
}

float *
arcocoseno_1_svc(float a,  struct svc_req *rqstp)
{
	static float  result;

	result = acos(a)*180.0/M_PI;

	return &result;
}

float *
arcotangente_1_svc(float a,  struct svc_req *rqstp)
{
	static float  result;

	result = atan(a)*180.0/M_PI;

	return &result;
}

float *
raiz_cuadrada_1_svc(float a,  struct svc_req *rqstp)
{
	static float  result;

	result = sqrt(a);

	return &result;
}

float *
potencia_1_svc(float a, float b,  struct svc_req *rqstp)
{
	static float  result;

	result = pow(a, b);

	return &result;
}

float_array *
suma_vectores_1_svc(float_array a, float_array b,  struct svc_req *rqstp)
{
	static float_array result;
	result.tam = a.tam;
	
	for(int i = 0; i < result.tam; i++)
		result.vector[i] = a.vector[i] + b.vector[i];

	return &result;
}

float_array *
resta_vectores_1_svc(float_array a, float_array b,  struct svc_req *rqstp)
{
	static float_array  result;
	result.tam = a.tam;
	
	for(int i = 0; i < result.tam; i++)
		result.vector[i] = a.vector[i] - b.vector[i];

	return &result;
}

float *
producto_escalar_1_svc(float_array a, float_array b,  struct svc_req *rqstp)
{
	static float  result;
	result = 0;
	
	for(int i = 0; i < a.tam; i++)
		result += a.vector[i] * b.vector[i];

	return &result;
}

float_array *
producto_vectorial_1_svc(float_array a, float_array b,  struct svc_req *rqstp)
{
	static float_array  result;
	result.tam = 3;

	result.vector[0] = a.vector[1]*b.vector[2] - a.vector[2]*b.vector[1];
	result.vector[1] = a.vector[2]*b.vector[0] - a.vector[0]*b.vector[2];
	result.vector[2] = a.vector[0]*b.vector[1] - a.vector[1]*b.vector[0];

	return &result;
}

float_matrix *
suma_matrices_1_svc(float_matrix a, float_matrix b,  struct svc_req *rqstp)
{
	static float_matrix  result;
	result.tam1 = a.tam1;
	result.tam2 = a.tam2;

	for(int i = 0; i < result.tam1 * result.tam2; i++)
		result.m[i] = a.m[i] + b.m[i];

	return &result;
}

float_matrix *
resta_matrices_1_svc(float_matrix a, float_matrix b,  struct svc_req *rqstp)
{
	static float_matrix  result;
	result.tam1 = a.tam1;
	result.tam2 = a.tam2;

	for(int i = 0; i < result.tam1 * result.tam2; i++)
		result.m[i] = a.m[i] - b.m[i];

	return &result;
}

float_matrix *
multiplicacion_matrices_1_svc(float_matrix a, float_matrix b,  struct svc_req *rqstp)
{
	static float_matrix result;
	float suma;
	result.tam1 = a.tam1;
	result.tam2 = a.tam2;

	for(int i = 0; i < b.tam1; i++){
		for(int j = 0; j < a.tam2; j++){
			suma = 0.0;
			for(int k = 0; k < a.tam1; k++){
				suma += a.m[k+a.tam1*j] * b.m[i+b.tam1*k];
			}
			result.m[i+a.tam1*j] = suma;
		}
	}

	return &result;
}

float_matrix *
division_matriz_real_1_svc(float_matrix a, float b,  struct svc_req *rqstp)
{
	static float_matrix  result;
	result.tam1 = a.tam1;
	result.tam2 = a.tam2;

	for(int i = 0; i < result.tam1 * result.tam2; i++)
		result.m[i] = a.m[i] / b;

	return &result;
}
